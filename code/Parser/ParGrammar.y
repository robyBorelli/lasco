-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Parser.ParGrammar
  ( happyError
  , myLexer
  , myShallowLexer
  , pProgram
  , parse
  ) where

import Prelude

import qualified Parser.AbsGrammar as AbsGrammar
import Parser.LexUtilities
import Parser.LexGrammar
import Parser.ShallowLexGrammar (shallowTokens)

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='             { PT _ (TS _ 1)              }
  '#neg'           { PT _ (TS _ 2)              }
  '#pos'           { PT _ (TS _ 3)              }
  '('              { PT _ (TS _ 4)              }
  ')'              { PT _ (TS _ 5)              }
  '*'              { PT _ (TS _ 6)              }
  '+'              { PT _ (TS _ 7)              }
  ','              { PT _ (TS _ 8)              }
  '-'              { PT _ (TS _ 9)              }
  '.'              { PT _ (TS _ 10)             }
  '..'             { PT _ (TS _ 11)             }
  '/'              { PT _ (TS _ 12)             }
  ':'              { PT _ (TS _ 13)             }
  ':-'             { PT _ (TS _ 14)             }
  ';'              { PT _ (TS _ 15)             }
  '<'              { PT _ (TS _ 16)             }
  '<='             { PT _ (TS _ 17)             }
  '='              { PT _ (TS _ 18)             }
  '=='             { PT _ (TS _ 19)             }
  '>'              { PT _ (TS _ 20)             }
  '>='             { PT _ (TS _ 21)             }
  'not'            { PT _ (TS _ 22)             }
  '{'              { PT _ (TS _ 23)             }
  '|'              { PT _ (TS _ 24)             }
  '}'              { PT _ (TS _ 25)             }
  '~'              { PT _ (TS _ 26)             }
  L_integ          { PT _ (TI $$)               }
  L_quoted         { PT _ (TL $$)               }
  L_VariableSymbol { PT _ (T_VariableSymbol $$) }
  L_BasicSymbol    { PT _ (T_BasicSymbol $$)    }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

VariableSymbol :: { AbsGrammar.VariableSymbol }
VariableSymbol  : L_VariableSymbol { AbsGrammar.VariableSymbol $1 }

BasicSymbol :: { AbsGrammar.BasicSymbol }
BasicSymbol  : L_BasicSymbol { AbsGrammar.BasicSymbol $1 }

Program :: { AbsGrammar.Program }
Program : ListDeclaration { AbsGrammar.Task $1 }

Declaration :: { AbsGrammar.Declaration }
Declaration
  : AspDeclaration { AbsGrammar.AspRule $1 }
  | '#pos' Example { AbsGrammar.PositiveExample $2 }
  | '#neg' Example { AbsGrammar.NegativeExample $2 }
  | Integer '~' AspDeclaration { AbsGrammar.Hypothesis 0 $1 $3 }

AspDeclaration :: { AbsGrammar.AspDeclaration }
AspDeclaration
  : Head ':-' ListLiteral { AbsGrammar.NormalRule $1 $3 }
  | Atom { AbsGrammar.Fact $1 }
  | ':-' ListLiteral { AbsGrammar.Denial $2 }
  | BasicSymbol '(' Integer '..' Integer ')' { AbsGrammar.Range $1 $3 $5 }
  | Bound '{' ListChoiceElem '}' Bound { AbsGrammar.NormalRule (AbsGrammar.ChoiceHead $1 $3 $5) [] }

Head :: { AbsGrammar.Head }
Head
  : Atom { AbsGrammar.SimpleHead $1 }
  | Bound '{' ListChoiceElem '}' Bound { AbsGrammar.ChoiceHead $1 $3 $5 }

Bound :: { AbsGrammar.Bound }
Bound
  : Integer { AbsGrammar.ExplicitBound $1 }
  | {- empty -} { AbsGrammar.ImplicitBound }

ChoiceElem :: { AbsGrammar.ChoiceElem }
ChoiceElem
  : Atom ':' ListLiteral { --error "guarded elements not implemented"
    AbsGrammar.GuardedChoiceElem $1 $3 
  }
  | Atom { AbsGrammar.SimpleChoiceElem $1 }

Atom :: { AbsGrammar.Atom }
Atom
  : BasicSymbol { AbsGrammar.SimpleAtom $1 }
  | BasicSymbol '(' ListTerm ')' { AbsGrammar.CompositeAtom $1 $3 }

Term :: { AbsGrammar.Term }
Term
  : BasicSymbol { AbsGrammar.Constant $1 }
  | ArithmeticExpr { AbsGrammar.ArithmeticTerm $1 }
  | String { AbsGrammar.StringTerm $1 }
  | '(' Term ',' ListTerm ')' { AbsGrammar.TupleTerm $2 $4 }

Literal :: { AbsGrammar.Literal }
Literal
  : Atom { AbsGrammar.PositiveLiteral $1 }
  | 'not' Atom { AbsGrammar.NegativeLiteral $2 }
  | Term CompOp Term { 
    -- error "comparisons not implemented"
    AbsGrammar.ComparisonLiteral $1 $2 $3 }

CompOp :: { AbsGrammar.CompOp }
CompOp
  : '<' { AbsGrammar.CompOpLe }
  | '<=' { AbsGrammar.CompOpLeq }
  | '>' { AbsGrammar.CompOpGe }
  | '>=' { AbsGrammar.CompOpGeq }
  | '=' { AbsGrammar.CompOpEq }
  | '==' { AbsGrammar.CompOpEqq }
  | '!=' { AbsGrammar.CompOpNeq }

ArithmeticExpr :: { AbsGrammar.ArithmeticExpr }
ArithmeticExpr
  : ArithmeticExpr '+' ArithmeticExpr1 { -- error "arithmetic expressions not implemented"
  AbsGrammar.AddExpr $1 $3 }
  | ArithmeticExpr '-' ArithmeticExpr1 { -- error "arithmetic expressions not implemented"
  AbsGrammar.SubExpr $1 $3 }
  | ArithmeticExpr1 { $1 }

ArithmeticExpr1 :: { AbsGrammar.ArithmeticExpr }
ArithmeticExpr1
  : ArithmeticExpr1 '*' ArithmeticExpr2 { -- error "arithmetic expressions not implemented"
  AbsGrammar.MulExpr $1 $3 }
  | ArithmeticExpr1 '/' ArithmeticExpr2 { -- error "arithmetic expressions not implemented"
  AbsGrammar.DivExpr $1 $3 }
  | ArithmeticExpr2 { $1 }

ArithmeticExpr2 :: { AbsGrammar.ArithmeticExpr }
ArithmeticExpr2
  : '-' ArithmeticExpr3 { -- error "arithmetic expressions not implemented"
   AbsGrammar.NegExpr $2 }
  | ArithmeticExpr3 { $1 }

ArithmeticExpr3 :: { AbsGrammar.ArithmeticExpr }
ArithmeticExpr3
  : '|' ArithmeticExpr4 '|' { -- error "arithmetic expressions not implemented"
  AbsGrammar.AbsExpr $2 }
  | ArithmeticExpr4 { $1 }

ArithmeticExpr4 :: { AbsGrammar.ArithmeticExpr }
ArithmeticExpr4
  : VariableSymbol { -- error "variables are not supported"
  AbsGrammar.Variable $1 }
  | Integer { AbsGrammar.IntExpr $1 }
  | '(' ArithmeticExpr ')' { $2 }

Example :: { AbsGrammar.Example }
Example
  : '(' '{' ListAtom '}' ',' '{' ListAtom '}' ')' { AbsGrammar.LasExample $3 $7 }
  | '(' '{' ListAtom '}' ',' '{' ListAtom '}' ',' '{' ListAspDeclaration '}' ')' { -- error "context examples are not supported"
    AbsGrammar.LasCtxExample $3 $7 $11 }

ListLiteral :: { [AbsGrammar.Literal] }
ListLiteral
  : Literal { (:[]) $1 } | Literal ',' ListLiteral { (:) $1 $3 }

ListAtom :: { [AbsGrammar.Atom] }
ListAtom
  : {- empty -} { [] }
  | Atom { (:[]) $1 }
  | Atom ',' ListAtom { (:) $1 $3 }

ListChoiceElem :: { [AbsGrammar.ChoiceElem] }
ListChoiceElem
  : ChoiceElem { (:[]) $1 }
  | ChoiceElem ';' ListChoiceElem { (:) $1 $3 }

ListAspDeclaration :: { [AbsGrammar.AspDeclaration] }
ListAspDeclaration
  : {- empty -} { [] }
  | AspDeclaration '.' ListAspDeclaration { (:) $1 $3 }

ListTerm :: { [AbsGrammar.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

ListDeclaration :: { [AbsGrammar.Declaration] }
ListDeclaration
  : Declaration '.' { (:[]) $1 }
  | Declaration '.' ListDeclaration { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

myShallowLexer :: String -> [Token]
myShallowLexer = shallowTokens

parse :: LexerModality -> String -> Either String AbsGrammar.Program
parse Tight = pProgram . myLexer
parse Shallow = pProgram . myShallowLexer

}

