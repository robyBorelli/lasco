-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Parser.SkelGrammar where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Parser.AbsGrammar as AbsGrammar

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transVariableSymbol :: AbsGrammar.VariableSymbol -> Result
transVariableSymbol x = case x of
  AbsGrammar.VariableSymbol string -> failure x

transBasicSymbol :: AbsGrammar.BasicSymbol -> Result
transBasicSymbol x = case x of
  AbsGrammar.BasicSymbol string -> failure x

transProgram :: AbsGrammar.Program -> Result
transProgram x = case x of
  AbsGrammar.Task declarations -> failure x

transDeclaration :: AbsGrammar.Declaration -> Result
transDeclaration x = case x of
  AbsGrammar.AspRule aspdeclaration -> failure x
  AbsGrammar.PositiveExample example -> failure x
  AbsGrammar.NegativeExample example -> failure x
  AbsGrammar.Hypothesis _ integer aspdeclaration -> failure x

transAspDeclaration :: AbsGrammar.AspDeclaration -> Result
transAspDeclaration x = case x of
  AbsGrammar.NormalRule head literals -> failure x
  AbsGrammar.Fact atom -> failure x
  AbsGrammar.Denial literals -> failure x
  AbsGrammar.Range basicsymbol integer1 integer2 -> failure x

transHead :: AbsGrammar.Head -> Result
transHead x = case x of
  AbsGrammar.SimpleHead atom -> failure x
  AbsGrammar.ChoiceHead bound1 choiceelems bound2 -> failure x

transBound :: AbsGrammar.Bound -> Result
transBound x = case x of
  AbsGrammar.ExplicitBound integer -> failure x
  AbsGrammar.ImplicitBound -> failure x

transChoiceElem :: AbsGrammar.ChoiceElem -> Result
transChoiceElem x = case x of
  AbsGrammar.GuardedChoiceElem atom literals -> failure x
  AbsGrammar.SimpleChoiceElem atom -> failure x

transAtom :: AbsGrammar.Atom -> Result
transAtom x = case x of
  AbsGrammar.SimpleAtom basicsymbol -> failure x
  AbsGrammar.CompositeAtom basicsymbol terms -> failure x

transTerm :: AbsGrammar.Term -> Result
transTerm x = case x of
  AbsGrammar.Constant basicsymbol -> failure x
  AbsGrammar.ArithmeticTerm arithmeticexpr -> failure x
  AbsGrammar.StringTerm string -> failure x
  AbsGrammar.TupleTerm term terms -> failure x

transLiteral :: AbsGrammar.Literal -> Result
transLiteral x = case x of
  AbsGrammar.PositiveLiteral atom -> failure x
  AbsGrammar.NegativeLiteral atom -> failure x
  AbsGrammar.ComparisonLiteral term1 compop term2 -> failure x

transCompOp :: AbsGrammar.CompOp -> Result
transCompOp x = case x of
  AbsGrammar.CompOpLe -> failure x
  AbsGrammar.CompOpLeq -> failure x
  AbsGrammar.CompOpGe -> failure x
  AbsGrammar.CompOpGeq -> failure x
  AbsGrammar.CompOpEq -> failure x
  AbsGrammar.CompOpEqq -> failure x
  AbsGrammar.CompOpNeq -> failure x

transArithmeticExpr :: AbsGrammar.ArithmeticExpr -> Result
transArithmeticExpr x = case x of
  AbsGrammar.AddExpr arithmeticexpr1 arithmeticexpr2 -> failure x
  AbsGrammar.SubExpr arithmeticexpr1 arithmeticexpr2 -> failure x
  AbsGrammar.MulExpr arithmeticexpr1 arithmeticexpr2 -> failure x
  AbsGrammar.DivExpr arithmeticexpr1 arithmeticexpr2 -> failure x
  AbsGrammar.NegExpr arithmeticexpr -> failure x
  AbsGrammar.AbsExpr arithmeticexpr -> failure x
  AbsGrammar.Variable variablesymbol -> failure x
  AbsGrammar.IntExpr integer -> failure x

transExample :: AbsGrammar.Example -> Result
transExample x = case x of
  AbsGrammar.LasExample atoms1 atoms2 -> failure x
  AbsGrammar.LasCtxExample atoms1 atoms2 aspdeclarations -> failure x
